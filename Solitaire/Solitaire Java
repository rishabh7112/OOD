package cs3500.pyramidsolitaire.controller;

import cs3500.pyramidsolitaire.model.hw02.PyramidSolitaireModel;

import java.util.List;

/**
 * Provides a controller for interacting with a game of Pyramid Solitaire.
 */
public interface PyramidSolitaireController {

  /**
   * The primary method for beginning and playing a game.
   *
   * @param <K>     the type of cards used by the model.
   * @param model   The game of solitaire to be played
   * @param deck    The deck of cards to be used
   * @param shuffle Whether to shuffle the deck or not
   * @param numRows How many rows should be in the pyramid
   * @param numDraw How many draw cards should be visible
   * @throws IllegalArgumentException if the model or deck is null
   * @throws IllegalStateException    if the game cannot be started, or if the controller cannot
   *                                  interact with the player.
   */
  <K> void playGame(PyramidSolitaireModel<K> model, List<K> deck,
      boolean shuffle, int numRows, int numDraw);
}

package cs3500.pyramidsolitaire.controller;

import cs3500.pyramidsolitaire.model.hw02.PyramidSolitaireModel;
import cs3500.pyramidsolitaire.view.PyramidSolitaireTextualView;
import cs3500.pyramidsolitaire.view.PyramidSolitaireView;
import java.io.IOException;
import java.util.List;
import java.util.Scanner;

/**
 * represents the controller for the basic pyramid model. It reads the inputs from users and calls
 * methods from the model accordingly.
 */
public class PyramidSolitaireTextualController implements PyramidSolitaireController {

  private Appendable ap;
  private final Scanner scan;

  /**
   * represents the constructor for the PyramidSolitaireTextualController.
   *
   * @param rd represents the Readable to read inputs
   * @param ap represents the Appendable that outputs the inputs
   * @throws IllegalArgumentException if Readable or Appendable are null
   */

  public PyramidSolitaireTextualController(Readable rd, Appendable ap)
      throws IllegalArgumentException {
    if (rd == null || ap == null) {
      throw new IllegalArgumentException("Invalid arguments");
    }
    this.ap = ap;
    this.scan = new Scanner(rd);
  }

  //checks if each input is either a q,Q, or a number
  private boolean getInput(int[] inputs, int n) {
    for (int i = 0; i < n; i++) {
      String valid;
      while (true) {
        try {
          String next = scan.next();
          if (next.toLowerCase().equals("q")) {
            valid = "q";
            break;
          } else {
            try {
              Integer.parseInt(next);
              valid = next;
              break;
            } catch (NumberFormatException e) {
              continue;
            }
          }
        } catch (IllegalStateException e) {
          throw new IllegalStateException("No more inputs available");
        }
      }
      if (valid.equals("q")) {
        return false;
      }
      inputs[i] = Integer.parseInt(valid);
    }
    return true;
  }

  //produces the quit message
  private <K> void quitMessage(PyramidSolitaireModel<K> model) throws IOException {
    PyramidSolitaireView p = new PyramidSolitaireTextualView(model);
    ap.append(
        "Game quit!" + "\n" + "State of game when quit:" + "\n" + p.toString() + "\n"
            + "Score: " + model.getScore());
  }

  /**
   * The primary method for beginning and playing a game.
   *
   * @param <K>     the type of cards used by the model.
   * @param model   The game of solitaire to be played
   * @param deck    The deck of cards to be used
   * @param shuffle Whether to shuffle the deck or not
   * @param numRows How many rows should be in the pyramid
   * @param numDraw How many draw cards should be visible
   * @throws IllegalArgumentException if the model or deck is null
   * @throws IllegalStateException    if the game cannot be started, or if the controller cannot
   *                                  interact with the player.
   */
  @Override
  public <K> void playGame(PyramidSolitaireModel<K> model, List<K> deck, boolean shuffle,
      int numRows, int numDraw)
      throws IllegalArgumentException, IllegalStateException {

    if (model == null || deck == null) {
      throw new IllegalArgumentException("Model or deck is null");
    }

    try {
      model.startGame(deck, shuffle, numRows, numDraw);
    } catch (IllegalArgumentException e) {
      throw new IllegalStateException("The game cannot start with current state");
    }

    PyramidSolitaireView view = new PyramidSolitaireTextualView(model, this.ap);

    String command;
    int[] inputs = new int[4];
    boolean cont = false;

    try {
      view.render();
      ap.append("\n");
      ap.append("Score: " + model.getScore() + "\n");
      while (!model.isGameOver() && scan.hasNext()) {
        command = scan.next();
        switch (command) {
          case "rm1":
            cont = getInput(inputs, 2);
            if (!cont) {
              quitMessage(model);
              return;
            }
            try {
              model.remove(inputs[0] - 1, inputs[1] - 1);
            } catch (IllegalArgumentException e) {
              ap.append("Invalid Move. Play Again. " + e.getMessage() + "\n");
            }
            break;
          case "rm2":
            cont = getInput(inputs, 4);
            if (!cont) {
              quitMessage(model);
              return;
            }
            try {
              model.remove(inputs[0] - 1, inputs[1] - 1, inputs[2] - 1, inputs[3] - 1);
            } catch (IllegalArgumentException e) {
              ap.append("Invalid Move. Play Again. " + e.getMessage() + "\n");
            }
            break;
          case "rmwd":
            cont = getInput(inputs, 3);
            if (!cont) {
              quitMessage(model);
              return;
            }
            try {
              model.removeUsingDraw(inputs[0] - 1, inputs[1] - 1, inputs[2] - 1);
            } catch (IllegalArgumentException e) {
              ap.append("Invalid Move. Play Again. " + e.getMessage() + "\n");
            }
            break;
          case "dd":
            cont = getInput(inputs, 1);
            if (!cont) {
              quitMessage(model);
              return;
            }
            try {
              model.discardDraw(inputs[0] - 1);
            } catch (IllegalArgumentException e) {
              ap.append("Invalid Move. Play Again. " + e.getMessage() + "\n");
            }
            break;
          case "q":
          case "Q":
            quitMessage(model);
            return;
          default:
            ap.append("Put proper move \n");
        }
        if (model.isGameOver()) {
          break;
        }
        view.render();
        ap.append("\n");
        ap.append("Score: " + model.getScore() + "\n");

      }
      if (model.getScore() == 0) {
        ap.append("You win!");
      } else {
        ap.append("Game over. Score: " + model.getScore());
      }
    } catch (IOException e) {
      throw new IllegalStateException("Invalid input/output");
    }
  }
}

package cs3500.pyramidsolitaire.model.hw02;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;

/**
 * represents a model for the pyramid solitaire game.
 */
public class BasicPyramidSolitaire implements PyramidSolitaireModel<Card> {

  protected int numRows;
  protected int numDraw;
  protected List<Card> drawCards;
  protected ArrayList<ArrayList<Card>> pyramid;

  /**
   * Zero argument Constructor that initializes the data.
   */
  public BasicPyramidSolitaire() {
    this.numRows = 0;
    this.numDraw = 0;
    this.drawCards = new ArrayList<Card>();
    this.pyramid = new ArrayList<ArrayList<Card>>();
  }


  /**
   * Return a valid and complete deck of cards.
   *
   * @return the deck of cards as a list
   */
  public List<Card> getDeck() {
    List<Card> cards = new ArrayList<>();
    for (Card.Rank r : Card.Rank.values()) {
      for (Card.Suit s : Card.Suit.values()) {
        cards.add(new Card(r, s));
      }
    }
    return cards;
  }

  /**
   * starts the game.
   *
   * @param deck    the deck to be dealt
   * @param shuffle if {@code false}, use the order as given by {@code deck}, otherwise use a
   *                randomly shuffled order
   * @param numRows number of rows in the pyramid
   * @param numDraw number of draw cards available at a time
   * @throws IllegalArgumentException if the deck is null or invalid, the number of pyramid rows is
   *                                  non-positive,  the number of draw cards available at a time is
   *                                  negative, or a full pyramid and draw pile cannot be dealt with
   *                                  the number of given cards in deck
   */
  public void startGame(List<Card> deck, boolean shuffle, int numRows, int numDraw)
      throws IllegalArgumentException {

    //Check deck is not null
    if (deck == null) {
      throw new IllegalArgumentException("Deck can't be null");
    }
    //Check deck is valid
    HashSet<Card> unique = new HashSet<Card>(deck);
    if (unique.size() != 52) {
      throw new IllegalArgumentException("Deck is not valid");
    }
    //Check int parameters to be valid
    if (numDraw < 0 || numRows <= 0) {
      throw new IllegalArgumentException("Num rows and num draw have to be positive");
    }
    //Check for a valid game inputs
    if ((numRows * (numRows + 1)) / 2 + numDraw > 52) {
      throw new IllegalArgumentException("Game can't be initialized with given parameters");
    }
    //Once all checks are done, start filling up the pyramid
    deck = new ArrayList<Card>(deck);
    this.numRows = numRows;
    this.numDraw = numDraw;
    //Check if shuffle is needed to start
    if (shuffle) {
      Collections.shuffle(deck);
    }
    //Deal cards into pyramid
    pyramid = new ArrayList<ArrayList<Card>>();
    for (int i = 0; i < numRows; i++) {
      ArrayList<Card> row = new ArrayList<Card>();
      pyramid.add(row);
      for (int j = 0; j <= i; j++) {

        Card c = deck.remove(0);
        row.add(c);

      }
      //Add remaining cards into draw deck
      drawCards = new ArrayList<Card>(deck);
    }
  }

  /**
   * Remove two exposed cards on the pyramid, using the two specified card positions.
   *
   * @param row1  row of first card position, numbered from 0 from the top of the pyramid
   * @param card1 card of first card position, numbered from 0 from left
   * @param row2  row of second card position
   * @param card2 card of second card position
   * @throws IllegalArgumentException if the attempted remove is invalid
   * @throws IllegalStateException    if the game has not yet been started
   */
  public void remove(int row1, int card1, int row2, int card2)
      throws IllegalArgumentException, IllegalStateException {
    //Check state of game
    if (pyramid.size() == 0) {
      throw new IllegalStateException("Game has not started yet");
    }
    //Check for valid removal
    boolean valid = false;
    if (row1 >= 0 && row1 < numRows && card1 >= 0 && card1 < pyramid.get(row1).size()
        && row2 >= 0 && row2 < numRows && card2 >= 0 && card2 < pyramid.get(row2).size()) {
      //Check front cards to be removed
      //Check card 1 valid
      if (((row1 == numRows - 1) || (pyramid.get(row1 + 1).get(card1) == null
          && pyramid.get(row1 + 1).get(card1 + 1) == null)) &&
          ((row2 == numRows - 1) || (pyramid.get(row2 + 1).get(card2) == null
              && pyramid.get(row2 + 1).get(card2 + 1) == null))) {
        valid = true;
      }
    }
    if (valid && pyramid.get(row1).get(card1) != null &&
        pyramid.get(row2).get(card2) != null &&
        pyramid.get(row1).get(card1).getRank().value() +
            pyramid.get(row2).get(card2).getRank().value() == 13) {
      pyramid.get(row1).set(card1, null);
      pyramid.get(row2).set(card2, null);
    } else {
      throw new IllegalArgumentException("Removal for requested cards is not possible");
    }
  }

  /**
   * Remove a single card on the pyramid, using the specified card position.
   *
   * @param row  row of the desired card position, numbered from 0 from the top of the pyramid
   * @param card card of the desired card position, numbered from 0 from left
   * @throws IllegalArgumentException if the attempted remove is invalid
   * @throws IllegalStateException    if the game has not yet been started
   */
  public void remove(int row, int card) throws IllegalArgumentException, IllegalStateException {
    if (pyramid.size() == 0) {
      throw new IllegalStateException("Game has not started yet");
    }
    //Check for valid removal
    boolean valid = false;
    if (row >= 0 && row < numRows && card >= 0 && card < pyramid.get(row).size()) {
      //Check front cards to be removed
      //Check card 1 valid
      if (((row == numRows - 1) || (pyramid.get(row + 1).get(card) == null
          && pyramid.get(row + 1).get(card + 1) == null))) {
        valid = true;
      }
    }
    if (valid && pyramid.get(row).get(card) != null &&
        pyramid.get(row).get(card).getRank().value() == 13) {
      pyramid.get(row).set(card, null);
    } else {
      throw new IllegalArgumentException("Removal for requested card is not possible");
    }
  }

  /**
   * Remove two cards, one from the draw pile and one from the pyramid.
   *
   * @param drawIndex the card from the draw pile, numbered from 0 from left
   * @param row       row of the desired card position, numbered from 0 from the top of the pyramid
   * @param card      card of the desired card position, numbered from 0 from left
   * @throws IllegalArgumentException if the attempted remove is invalid
   * @throws IllegalStateException    if the game has not yet been started
   */
  public void removeUsingDraw(int drawIndex, int row, int card)
      throws IllegalArgumentException, IllegalStateException {
    if (pyramid.size() == 0) {
      throw new IllegalStateException("Game has not started yet");
    }
    //Check for valid removal
    boolean valid = false;
    if (row >= 0 && row < numRows && card >= 0 && card < pyramid.get(row).size()) {
      //Check front cards to be removed
      //Check card 1 valid
      if (((row == numRows - 1) || (pyramid.get(row + 1).get(card) == null
          && pyramid.get(row + 1).get(card + 1) == null))) {
        valid = true;
      }
    }
    if (valid && pyramid.get(row).get(card) != null && drawIndex >= 0
        && drawIndex < numDraw && drawIndex < drawCards.size()
        && drawCards.get(drawIndex).getRank().value() +
        pyramid.get(row).get(card).getRank().value() == 13) {
      pyramid.get(row).set(card, null);
      drawCards.remove(drawIndex);
    } else {
      throw new IllegalArgumentException("Removal for requested card is not possible");
    }

  }

  /**
   * Discards an individual card from the draw pile.
   *
   * @param drawIndex the card from the draw pile to be discarded
   * @throws IllegalArgumentException if the index is invalid or no card is present there
   * @throws IllegalStateException    if the game has not yet been started
   */
  public void discardDraw(int drawIndex) throws IllegalArgumentException, IllegalStateException {
    if (pyramid.size() == 0) {
      throw new IllegalStateException("Game has not started yet");
    }
    //Check for valid removal
    if (drawIndex >= 0 && drawIndex < numDraw && drawIndex < drawCards.size()) {
      drawCards.remove(drawIndex);
    } else {
      throw new IllegalArgumentException("Removal for requested card is not possible");
    }
  }

  /**
   * Returns the number of rows originally in the pyramid, or -1 if the game hasn't been started.
   *
   * @return the height of the pyramid, or -1
   */
  public int getNumRows() {
    if (pyramid.size() == 0) {
      return -1;
    }
    return numRows;
  }

  /**
   * Returns the maximum number of visible cards in the draw pile, or -1 if the game hasn't been
   * started.
   *
   * @return the number of visible cards in the draw pile, or -1
   */
  public int getNumDraw() {
    if (pyramid.size() == 0) {
      return -1;
    }
    return numDraw;
  }

  /**
   * Returns the width of the requested row, measured from the leftmost card to the rightmost card
   * (inclusive) as the game is initially dealt.
   *
   * @param row the desired row (0-indexed)
   * @return the number of spaces needed to deal out that row
   * @throws IllegalArgumentException if the row is invalid
   * @throws IllegalStateException    if the game has not yet been started
   */
  public int getRowWidth(int row) {
    if (pyramid.size() == 0) {
      throw new IllegalStateException("Game has not started yet");
    }
    if (row >= 0 && row < numRows) {
      return pyramid.get(row).size();
    } else {
      throw new IllegalArgumentException("Invalid row requested");
    }
  }

  /**
   * Signal if the game is over or not. A game is said to be over if there are no possible removes
   * or discards.
   *
   * @return true if game is over, false otherwise
   * @throws IllegalStateException if the game hasn't been started yet
   */
  public boolean isGameOver() throws IllegalStateException {
    if (pyramid.size() == 0) {
      throw new IllegalStateException("Game has not started yet");
    }
    if (getScore() == 0) {
      //Player won!
      return true;
    }
    if (numDraw < drawCards.size()) {
      return false;
    }
    List<Card> availableCards = getAvailableCards();
    for (int i = 0; i < availableCards.size(); i++) {
      for (int j = i + 1; j < availableCards.size(); j++) {
        if (availableCards.get(i).getRank().value() +
            availableCards.get(j).getRank().value() == 13) {
          return false;
        } else if (availableCards.get(i).getRank().value() == 13) {
          return false;
        }
      }
    }
    return true;
  }

  /**
   * gets the list of available cards in the pyramid.
   *
   * @return the list of available cards in the pyramid
   */
  protected List<Card> getAvailableCards() {
    List<Card> cards = new ArrayList<Card>(drawCards);
    for (int i = 0; i < numRows; i++) {
      for (int j = numRows - 1; j >= 0 && j >= i; j--) {
        if (pyramid.get(j).get(i) != null && ((j == numRows - 1) ||
            (pyramid.get(j + 1).get(i) == null
                && pyramid.get(j + 1).get(i + 1) == null))) {
          cards.add(pyramid.get(j).get(i));
          break;
        }
      }
    }
    return cards;
  }

  /**
   * Return the current score, which is the sum of the values of the cards remaining in the
   * pyramid.
   *
   * @return the score
   * @throws IllegalStateException if the game hasn't been started yet
   */
  public int getScore() throws IllegalStateException {
    if (pyramid.size() == 0) {
      throw new IllegalStateException("Game has not started yet");
    }
    int score = 0;
    for (int i = 0; i < numRows; i++) {
      for (int j = 0; j <= i; j++) {
        if (pyramid.get(i).get(j) != null) {
          score += pyramid.get(i).get(j).getRank().value();
        }
      }
    }
    return score;
  }

  /**
   * Returns the card at the specified coordinates.
   *
   * @param row  row of the desired card (0-indexed from the top)
   * @param card column of the desired card (0-indexed from the left)
   * @return the card at the given position, or <code>null</code> if no card is there
   * @throws IllegalArgumentException if the coordinates are invalid
   * @throws IllegalStateException    if the game hasn't been started yet
   */
  public Card getCardAt(int row, int card) throws IllegalStateException {
    if (pyramid.size() == 0) {
      throw new IllegalStateException("Game has not started yet");
    }
    if (row >= 0 && row < numRows && card >= 0 && card < pyramid.get(row).size()) {
      return pyramid.get(row).get(card);
    } else {
      throw new IllegalArgumentException("Invalid card requested " + row + " " + card);
    }
  }

  /**
   * Returns the currently available draw cards. There should be at most {@link
   * PyramidSolitaireModel#getNumDraw} cards (the number specified when the game started) -- there
   * may be fewer, if cards have been removed.
   *
   * @return the ordered list of available draw cards
   * @throws IllegalStateException if the game hasn't been started yet
   */
  public List<Card> getDrawCards() throws IllegalStateException {
    ArrayList<Card> visible = new ArrayList<Card>();
    for (int i = 0; i < numDraw && i < drawCards.size(); i++) {
      visible.add(drawCards.get(i));
    }
    return visible;
  }

}


package cs3500.pyramidsolitaire.model.hw02;

import java.util.Objects;

/**
 * represents the cards that will be used in the solitaire game.
 */

public class Card {

  private final Rank value;
  private final Suit suit;

  /**
   * enumeration of the rank of cards.
   */
  public enum Rank {
    A(1),
    TWO(2),
    THREE(3),
    FOUR(4),
    FIVE(5),
    SIX(6),
    SEVEN(7),
    EIGHT(8),
    NINE(9),
    TEN(10),
    J(11),
    Q(12),
    K(13);

    private int value;

    /**
     * Rank Constructor.
     *
     * @param value represents the value of card
     */
    Rank(int value) {
      this.value = value;
    }

    /**
     * gets the value of rank.
     *
     * @return the value of rank.
     */
    public int value() {
      return value;
    }
  }

  /**
   * enumeration of the suit of cards.
   */
  public enum Suit {
    SPADES('♠'), CLUBS('♣'), DIAMONDS('♦'), HEARTS('♥');

    private char c;

    /**
     * Constructor for Suit.
     *
     * @param c represents the suit
     */
    Suit(char c) {
      this.c = c;
    }

    /**
     * returns the suit symbol of the corresponding card.
     *
     * @return the suit symbol.
     */
    public char suit() {
      return c;
    }
  }

  /**
   * 2 Argument constructor of Card.
   *
   * @param value represents the value of the rank
   * @param suit  represents the suit of the card
   */
  public Card(Rank value, Suit suit) {
    this.value = value;
    this.suit = suit;
  }

  /**
   * the way the cards will be printed.
   *
   * @return the string version of the card
   */
  public String toString() {
    if (value == Rank.A || value == Rank.J || value == Rank.Q || value == Rank.K) {
      return value + "" + suit.suit();
    }
    return value.value + "" + suit.suit();
  }

  /**
   * gets the value of the rank.
   *
   * @return the value of rank
   */
  public Rank getRank() {
    return value;
  }

  /**
   * gets the suit of the card.
   *
   * @return the suit of the card
   */
  public Suit getSuit() {
    return suit;
  }

  /**
   * overrides the equals method to compare cards.
   *
   * @param o object
   * @return true if the cards are the same
   */
  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Card card = (Card) o;
    return value == card.value &&
        suit == card.suit;
  }

  @Override
  public int hashCode() {
    return Objects.hash(value, suit);
  }

}


package cs3500.pyramidsolitaire.model.hw02;

import java.util.List;

/**
 * The model for playing a game of Pyramid Solitaire: this maintains the state and enforces the
 * rules of gameplay.
 *
 * @param <K> the type of cards this model uses
 */
public interface PyramidSolitaireModel<K> {

  /**
   * Return a valid and complete deck of cards for a game of Pyramid Solitaire. There is no
   * restriction imposed on the ordering of these cards in the deck. The validity of the deck is
   * determined by the rules of the specific game in the classes implementing this interface.
   *
   * @return the deck of cards as a list
   */
  List<K> getDeck();

  /**
   * <p>Deal a new game of Pyramid Solitaire.
   * The cards to be used and their order are specified by the the given deck, unless the {@code
   * shuffle} parameter indicates the order should be ignored.</p>
   *
   * <p>This method first verifies that the deck is valid. It deals cards in rows
   * (left-to-right, top-to-bottom) into the characteristic pyramid shape with the specified number
   * of rows, followed by the specified number of draw cards. When {@code shuffle} is {@code false},
   * the 0th card in {@code deck} is used as the first card dealt.</p>
   *
   * <p>This method should have no other side effects, and should work for any valid arguments.</p>
   *
   * @param deck    the deck to be dealt
   * @param shuffle if {@code false}, use the order as given by {@code deck}, otherwise use a
   *                randomly shuffled order
   * @param numRows number of rows in the pyramid
   * @param numDraw number of draw cards available at a time
   * @throws IllegalArgumentException if the deck is null or invalid, the number of pyramid rows or
   *                                  number of available draw cards is non-positive, or a full
   *                                  pyramid and draw pile cannot be dealt with the number of given
   *                                  cards in deck
   */
  void startGame(List<K> deck, boolean shuffle, int numRows, int numDraw)
      throws IllegalArgumentException;

  /**
   * Execute a two-card move on the pyramid, using the two specified card positions.
   *
   * @param row1  row of first card position, numbered from 0 from the top of the pyramid
   * @param card1 card of first card position, numbered from 0 from left
   * @param row2  row of second card position
   * @param card2 card of second card position
   * @throws IllegalArgumentException if the move is invalid
   * @throws IllegalStateException    if the game has not yet been started
   */
  void remove(int row1, int card1, int row2, int card2)
      throws IllegalArgumentException, IllegalStateException;

  /**
   * Execute a single-card move on the pyramid, using the specified card position.
   *
   * @param row  row of the desired card position, numbered from 0 from the top of the pyramid
   * @param card card of the desired card position, numbered from 0 from left
   * @throws IllegalArgumentException if the move is invalid
   * @throws IllegalStateException    if the game has not yet been started
   */
  void remove(int row, int card) throws IllegalArgumentException, IllegalStateException;

  /**
   * Execute a two-card move, using the specified card from the draw pile and the specified card
   * from the pyramid.
   *
   * @param row  row of the desired card position, numbered from 0 from the top of the pyramid
   * @param card card of the desired card position, numbered from 0 from left
   * @throws IllegalArgumentException if the move is invalid
   * @throws IllegalStateException    if the game has not yet been started
   */
  void removeUsingDraw(int drawIndex, int row, int card)
      throws IllegalArgumentException, IllegalStateException;

  /**
   * Discards an individual card from the draw pile.
   *
   * @param drawIndex the card to be discarded
   * @throws IllegalArgumentException if the index is invalid or no card is present there.
   * @throws IllegalStateException    if the game has not yet been started
   */

  void discardDraw(int drawIndex) throws IllegalArgumentException, IllegalStateException;

  /**
   * Returns the number of rows originally in the pyramid, or -1 if the game hasn't been started.
   *
   * @return the height of the pyramid, or -1
   */

  int getNumRows();

  /**
   * Returns the maximum number of visible cards in the draw pile, or -1 if the game hasn't been
   * started.
   *
   * @return the number of visible cards in the draw pile, or -1
   */
  int getNumDraw();

  /**
   * Returns the width of the requested row, measured from the leftmost card to the rightmost card
   * (inclusive) as the game is initially dealt.
   *
   * @param row the desired row (0-indexed)
   * @return the number of spaces needed to deal out that row
   * @throws IllegalArgumentException if the row is invalid
   * @throws IllegalStateException    if the game has not yet been started
   */
  int getRowWidth(int row);

  /**
   * Signal if the game is over or not.
   *
   * @return true if game is over, false otherwise
   * @throws IllegalStateException if the game hasn't been started yet
   */
  boolean isGameOver() throws IllegalStateException;

  /**
   * Return the current score, which is the sum of the values of the cards remaining in the
   * pyramid.
   *
   * @return the score
   * @throws IllegalStateException if the game hasn't been started yet
   */
  int getScore() throws IllegalStateException;

  /**
   * Returns the card at the specified coordinates.
   *
   * @param row  row of the desired card (0-indexed from the top)
   * @param card column of the desired card (0-indexed from the left)
   * @return the card at the given position, or <code>null</code> if no card is there
   * @throws IllegalArgumentException if the coordinates are invalid
   * @throws IllegalStateException    if the game hasn't been started yet
   */
  Card getCardAt(int row, int card) throws IllegalStateException;

  /**
   * Returns the currently available draw cards. There should be at most {@link
   * PyramidSolitaireModel#getNumDraw} cards (the number specified when the game started) -- there
   * may be fewer, if cards have been removed.
   *
   * @return the ordered list of available draw cards
   * @throws IllegalStateException if the game hasn't been started yet
   */
  List<K> getDrawCards() throws IllegalStateException;
}


package cs3500.pyramidsolitaire.model.hw04;

import cs3500.pyramidsolitaire.model.hw02.BasicPyramidSolitaire;
import cs3500.pyramidsolitaire.model.hw02.Card;
import java.util.ArrayList;
import java.util.List;
import java.util.Random;

/**
 * represents the multi pyramid model where there are 3 pyramids with 104 cards.
 */
public class MultiPyramidSolitaireModel extends BasicPyramidSolitaire {

  public MultiPyramidSolitaireModel() {
    super();
  }

  /**
   * Return a valid and complete(104) deck of cards.
   *
   * @return the deck of cards as a list
   */
  @Override
  public List<Card> getDeck() {
    List<Card> cards = new ArrayList<>();
    cards.addAll(super.getDeck());
    cards.addAll(super.getDeck());
    return cards;
  }

  /**
   * starts the game for the multipyramid in which it draws out 3 pyramids conjoined with the 104
   * card deck.
   *
   * @param deck    the deck to be dealt
   * @param shuffle if {@code false}, use the order as given by {@code deck}, otherwise use a
   *                randomly shuffled order
   * @param numRows number of rows in the pyramid
   * @param numDraw number of draw cards available at a time
   * @throws IllegalArgumentException if the deck is null or invalid, the number of pyramid rows is
   *                                  non-positive,  the number of draw cards available at a time is
   *                                  negative, or a full pyramid and draw pile cannot be dealt with
   *                                  the number of given cards in deck
   */
  @Override
  public void startGame(List<Card> deck, boolean shuffle, int numRows, int numDraw)
      throws IllegalArgumentException {
    //Check deck is not null
    if (deck == null) {
      throw new IllegalArgumentException("Deck can't be null");
    }
    //Check deck is valid
    if (deck.size() != 104 || !validDeck(deck)) {
      throw new IllegalArgumentException("Deck is not valid");
    }
    //Check int parameters to be valid
    if (numDraw < 0 || numRows <= 0) {
      throw new IllegalArgumentException("Num rows and num draw have to be positive");
    }
    //Check for a valid game inputs
    int numOverlap = (int) Math.ceil((numRows * 1.0) / 2);
    int total = (numRows * (numRows + 1)) / 2;
    total += (total - (numOverlap * (numOverlap + 1)) / 2) * 2;
    if (total + numDraw > 104) {
      throw new IllegalArgumentException("Game can't be initialized with given parameters");
    }
    //Once all checks are done, start filling up the pyramid
    deck = new ArrayList<Card>(deck);
    this.numRows = numRows;
    this.numDraw = numDraw;
    //Check if shuffle is needed to start
    if (shuffle) {
      Random r = new Random();
      for (int n = 1; n < 1000; n++) {
        int i = r.nextInt(deck.size());
        int j = r.nextInt(deck.size());
        //Swap values on indices
        Card temp = deck.get(i);
        deck.set(i, deck.get(j));
        deck.set(j, temp);
      }
    }
    //Deal cards into pyramid
    //Make initial number of spots needed
    pyramid = new ArrayList<ArrayList<Card>>();
    int num = (numRows - numOverlap) * 2 + 1;
    int step = numRows - numOverlap;
    for (int i = 0; i < numRows; i++) {
      ArrayList<Card> row = new ArrayList<Card>();
      if (i >= numRows - numOverlap - 1) {
        for (int j = 1; j <= num; j++) {
          Card c = deck.remove(0);
          row.add(c);
        }
      } else {
        for (int j = 0; j < num; j++) {
          row.add(null);
        }
        int start = 0;
        while (start < num) {
          for (int j = start; j <= start + i; j++) {
            Card c = deck.remove(0);
            row.set(j, c);
          }
          start += step;
        }
      }
      pyramid.add(row);
      num++;
    }
    //Add remaining cards into draw deck
    drawCards = new ArrayList<Card>(deck);
  }


  /**
   * checks if the deck is valid by seeing if there are only duplicates of each card in a deck.
   *
   * @param deck the deck to be dealt
   * @return true if the deck is valid and only has duplicate cards
   */
  private boolean validDeck(List<Card> deck) {
    boolean valid = true;
    ArrayList<String> cards = new ArrayList<String>();
    for (int i = 0; i < deck.size(); i++) {
      Card card = deck.get(i);
      if (!cards.contains(card.toString())) {
        cards.add(card.toString());
        int num = 1;
        for (int j = i + 1; j < deck.size(); j++) {
          if (deck.get(j).equals(card)) {
            num++;
          }
        }
        if (num != 2) {
          valid = false;
          break;
        }
      }
    }
    return valid;
  }

}


package cs3500.pyramidsolitaire.model.hw04;

import cs3500.pyramidsolitaire.model.hw02.BasicPyramidSolitaire;
import cs3500.pyramidsolitaire.model.hw02.Card;
import cs3500.pyramidsolitaire.model.hw02.PyramidSolitaireModel;

/**
 * represents the factory class in which it creates instances of each class.
 */
public class PyramidSolitaireCreator {

  /**
   * represents each of the models for the game.
   */
  public enum GameType {
    BASIC, RELAXED, MULTIPYRAMID
  }

  /**
   * represents the factory method that creates instances of each model class.
   *
   * @param type represents each type of model that is used for the game
   * @return PyramidSolitaireModel an instance of each model class
   */
  public static PyramidSolitaireModel<Card> create(GameType type) {
    if (type.equals(GameType.BASIC)) {
      return new BasicPyramidSolitaire();
    }
    if (type.equals(GameType.RELAXED)) {
      return new RelaxedPyramidSolitaireModel();
    }
    if (type.equals(GameType.MULTIPYRAMID)) {
      return new MultiPyramidSolitaireModel();
    }
    throw new IllegalArgumentException("invalid game type");
  }
}



package cs3500.pyramidsolitaire.model.hw04;

import cs3500.pyramidsolitaire.model.hw02.BasicPyramidSolitaire;
import cs3500.pyramidsolitaire.model.hw02.Card;
import java.util.List;

/**
 * represents the relaxed pyramid model where the rules are "relaxed".
 */
public class RelaxedPyramidSolitaireModel extends BasicPyramidSolitaire {

  public RelaxedPyramidSolitaireModel() {
    super();
  }

  /**
   * this remove method gives you the ability to remove 2 cards where 1 card is covered by only 1
   * card and they add up to 13.
   *
   * @param row1  row of first card position, numbered from 0 from the top of the pyramid
   * @param card1 card of first card position, numbered from 0 from left
   * @param row2  row of second card position
   * @param card2 card of second card position
   * @throws IllegalArgumentException if the removal for requested cards is not possible
   * @throws IllegalStateException    if the game hasn't started yet
   */
  public void remove(int row1, int card1, int row2, int card2)
      throws IllegalArgumentException, IllegalStateException {
    //Check state of game
    if (pyramid.size() == 0) {
      throw new IllegalStateException("Game has not started yet");
    }
    //Check for valid removal
    boolean valid = false;
    if (row1 >= 0 && row1 < numRows && card1 >= 0 && card1 <= row1
        && row2 >= 0 && row2 < numRows && card2 >= 0 && card2 <= row2) {
      //Check front cards to be removed
      //Check card 1 valid
      if (((row1 == numRows - 1) || ((pyramid.get(row1 + 1).get(card1) == null ||
          (row1 + 1 == row2 && card1 == card2 && pyramid.get(row1 + 1).get(card1 + 1) == null))
          && (pyramid.get(row1 + 1).get(card1 + 1) == null ||
          (row1 + 1 == row2 && card1 + 1 == card2 && pyramid.get(row1 + 1).get(card1) == null))))
          && ((row2 == numRows - 1) || ((pyramid.get(row2 + 1).get(card2) == null ||
          (row2 + 1 == row1 && card1 == card2 && pyramid.get(row2 + 1).get(card2 + 1) == null))
          && (pyramid.get(row2 + 1).get(card2 + 1) == null ||
          (row2 + 1 == row2 && card2 + 1 == card1 && pyramid.get(row2 + 1).get(card2) == null))))) {
        valid = true;
      }
    }
    if (valid && pyramid.get(row1).get(card1) != null &&
        pyramid.get(row2).get(card2) != null &&
        pyramid.get(row1).get(card1).getRank().value() +
            pyramid.get(row2).get(card2).getRank().value() == 13) {
      pyramid.get(row1).set(card1, null);
      pyramid.get(row2).set(card2, null);
    } else {
      throw new IllegalArgumentException("Removal for requested cards is not possible");
    }
  }

  /**
   * Goes through all the available cards as well as the "relaxed" cards to see if the game is
   * over.
   *
   * @return true if the game is over
   * @throws IllegalStateException if the game hasn't started
   */
  @Override
  public boolean isGameOver() throws IllegalStateException {
    if (pyramid.size() == 0) {
      throw new IllegalStateException("Game has not started yet");
    }
    if (getScore() == 0) {
      //Player won!
      return true;
    }
    if (numDraw < drawCards.size()) {
      return false;
    }
    //Check all visible cards!
    List<Card> availableCards = getAvailableCards();
    for (int i = 0; i < availableCards.size(); i++) {
      if (availableCards.get(i).getRank().value() == 13) {
        return false;
      }
      for (int j = i + 1; j < availableCards.size(); j++) {
        if (availableCards.get(i).getRank().value() +
            availableCards.get(j).getRank().value() == 13) {
          return false;
        }
      }
    }
    //Check possible cards to be relaxed
    for (int i = 0; i < numRows - 1; i++) {
      for (int j = 0; j <= i; j++) {
        if (pyramid.get(i).get(j) != null) {
          if ((pyramid.get(i + 1).get(j) != null &&
              pyramid.get(i + 1).get(j + 1) == null &&
              availableCards.contains(pyramid.get(i + 1).get(j))
              && pyramid.get(i).get(j).getRank().value() +
              pyramid.get(i + 1).get(j).getRank().value() == 13) ||
              (pyramid.get(i + 1).get(j + 1) != null &&
                  pyramid.get(i + 1).get(j) == null &&
                  availableCards.contains(pyramid.get(i + 1).get(j + 1))
                  && pyramid.get(i).get(j).getRank().value() +
                  pyramid.get(i + 1).get(j + 1).getRank().value() == 13)) {
            return false;
          }
        }
      }
    }
    return true;
  }
}



package cs3500.pyramidsolitaire.view;

import cs3500.pyramidsolitaire.model.hw02.PyramidSolitaireModel;
import java.io.IOException;

/**
 * represents the view for the game and renders the solitaire game.
 */
public class PyramidSolitaireTextualView implements PyramidSolitaireView {

  private final PyramidSolitaireModel<?> model;
  private Appendable ap;
  // ... any other fields you need

  /**
   * represents 2 argument constructor for the view.
   *
   * @param model represents the model for the pryamid solitaire game
   * @param ap    represents the Appendable which outputs from controller
   */

  public PyramidSolitaireTextualView(PyramidSolitaireModel<?> model, Appendable ap) {
    this.model = model;
    this.ap = ap;
  }

  /**
   * represents 1 argument constructor for the view.
   *
   * @param model represents the model for the pryamid solitaire game
   */
  public PyramidSolitaireTextualView(PyramidSolitaireModel<?> model) {
    this.model = model;
  }

  // produces the toString() of the game
  @Override
  public String toString() {
    //1. Check if game hasn't started yet
    if (model.getNumRows() == -1) {
      return "";
    }
    //2. Check if the player won the game (pyramid is emptied)
    if (model.getScore() == 0) {
      return "You win!";
    }
    //3. Check if game is over
    if (model.isGameOver()) {
      return "Game over. Score: " + model.getScore();
    }
    //4. Otherwise, return a String representing the pyramid
    String str = "";
    for (int i = 0; i < model.getNumRows(); i++) {
      String row = "";
      for (int j = 0; j < model.getRowWidth(i); j++) {
        Object card = model.getCardAt(i, j);
        if (card != null) {
          row += String.format("%-4s", card.toString());
        } else {
          row += ".   ";
        }
      }
      row = row.trim();
      int whites = 2 * (model.getNumRows() - 1 - i);
      if (whites > 0) {
        str += String.format("%" + whites + "s", "");
      }
      str += row + "\n";
    }
    str += "Draw: ";
    for (int i = 0; i < model.getNumDraw() && i < model.getDrawCards().size(); i++) {
      str += model.getDrawCards().get(i);
      if (i < model.getNumDraw() - 1 && i < model.getDrawCards().size() - 1) {
        str += ", ";
      }
    }
    return str;
  }

  /**
   * Renders a model in some manner (e.g. as text, or as graphics, etc.).
   *
   * @throws IOException if the rendering fails for some reason
   */
  @Override
  public void render() throws IOException {
    this.ap.append(this.toString());
  }
}


package cs3500.pyramidsolitaire.view;

import cs3500.pyramidsolitaire.model.hw02.PyramidSolitaireModel;

import java.io.IOException;

/**
 * Renders a {@link PyramidSolitaireModel} in some manner.
 */
public interface PyramidSolitaireView {

  /**
   * Renders a model in some manner (e.g. as text, or as graphics, etc.).
   *
   * @throws IOException if the rendering fails for some reason
   */
  void render() throws IOException;
}


package cs3500.pyramidsolitaire;

import cs3500.pyramidsolitaire.controller.PyramidSolitaireController;
import cs3500.pyramidsolitaire.controller.PyramidSolitaireTextualController;
import cs3500.pyramidsolitaire.model.hw02.Card;
import cs3500.pyramidsolitaire.model.hw02.PyramidSolitaireModel;
import cs3500.pyramidsolitaire.model.hw04.PyramidSolitaireCreator;
import cs3500.pyramidsolitaire.model.hw04.PyramidSolitaireCreator.GameType;
import java.io.InputStreamReader;

/**
 * represents the class that executes the game in real time using the main method.
 */
public final class PyramidSolitaire {

  /**
   * this is the main method where you can test play the game with various models.
   */
  public static void main(String[] args) {
    PyramidSolitaireController controller = new PyramidSolitaireTextualController(
        new InputStreamReader(System.in), System.out);
    PyramidSolitaireModel<Card> model;
    switch (args[0]) {

      case "basic":
        model = PyramidSolitaireCreator.create(GameType.BASIC);
        break;

      case "relaxed":
        model = PyramidSolitaireCreator.create(GameType.RELAXED);
        break;

      case "multipyramid":
        model = PyramidSolitaireCreator.create(GameType.MULTIPYRAMID);
        break;
      case "q":
      case "Q":
        return;

      default:
        return;
    }
    if (args.length == 1) {
      controller.playGame(model, model.getDeck(), true, 7, 3);

    }
    int a = Integer.parseInt(args[1]);
    int b = Integer.parseInt(args[2]);
    controller.playGame(model, model.getDeck(), true, a, b);
  }
}

